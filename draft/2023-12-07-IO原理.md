---
layout: post
title: IO原理
subtitle: IO
date: 2023-12-07 19:50:00 +0800
categories: IO
author: 月梦
cover: 'https://z1.ax1x.com/2023/12/01/pisYxbD.jpg'
cover_author: 'Pexels'
cover_author_link: 'https://www.pexels.com/zh-cn/'
tags:
- IO  
---

IO，即`Input/Output`，指的是程序从外部设备或者网络读取数据到用户态内存/从用户态内存写数据到外部设备或者网络的过程。  

## 普通的IO
一般的IO，其流程为，  
1. Java进程调用`read()` `write()`系统调用函数，进入内核态；  
2. 内核中的相关程序将数据从设备缓冲区拷贝到内核缓冲区中；  
3. 把数据从内核缓冲区拷贝到进程的地址空间中去  
这就完成了一次`Input`，`Output`反之。  

这里有两个耗时的操作，一是从设备拷贝数据到内核缓冲区，二是从内核缓冲区拷贝数据到进程的用户态内存空间。  

内核缓冲区的作用是解决第二个问题，一次性拷贝一批数据，从而避免频繁且缓慢的磁盘IO或者与其他设备的IO。  

字节缓冲流诸如`BufferedInputStream`作用是解决第一个问题，一次性从内核缓冲区拷贝一批数据到进程的缓冲区中，这个缓冲区位于进程的地址空间，之后接着取数据，如果缓冲区中还有数据，就无需系统调用，而拿到数据，避免了大量的系统调用开销。  

这是普通的IO操作，除此之外还有各种方式用于加快IO，譬如DMA等。  

## IO的方式
IO的方式有三种，分别是`BIO` `NIO`与`AIO`.  
### BIO
`BIO`是同步阻塞的IO，在`BIO`的方式下，我们处理网络IO请求需要：  
1. 为每个连接（具体表现为一个与套接字关联的对象实例）提供一个线程来处理数据传输；
2. 如果没有数据到达，该连接对应的线程就要阻塞等待，直到内核中的数据准备就绪；  

每个连接一个线程来处理的方式消耗大量的系统资源，因为线程会占用大概几MB内存，而我们的内存却是有限的，这样的方式注定无法处理太多的请求，这样就限制住了并发数量。  

### NIO
`NIO`是同步非阻塞IO，在`NIO`的方式下，相比`BIO`有如下优势：   
1. `NIO`不需要为每个连接开一个线程来处理，而是使用一个线程可以监听多个连接，当有连接准备就绪，则进行处理，大大减少了处理并发所需的线程数量；  
2. `NIO`中，当进行IO操作时，程序可以立即返回，而不需要等待操作完成，通过轮询或者监听，程序可以知道哪些连接已经准备好了数据或者可以写入数据了。程序可以针对就绪的连接执行数据处理操作，而不会阻塞某一个特定的IO上，因此称为非阻塞IO；  

### AIO
`AIO`是异步非阻塞IO，当进行读写的时候，进程只需要调用API的`read`或`write`方法，当内核中的数据准备好之后，通知进程去处理数据，不涉及阻塞，异步的特点是回调函数，与`NIO`不同的是，`read`或`write`方法会自动调用回调函数，而无需轮询。  

